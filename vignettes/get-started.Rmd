---
title: "Get started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{get-started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(mostlytidyMMM)
```

<!-- WARNING - This vignette is generated by {fusen} from dev/flat_full.Rmd: do not edit by hand -->

<!-- Run this 'development' chunk -->
<!-- Store every call to library() that you need to explore your functions -->


<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.

If it is the first time you use {fusen}, after 'description', you can directly run the last chunk of the present file with inflate() inside.
--> 


# Include some data examples in your package

<!-- 
 Store your dataset in a directory named "inst/" at the root of your project.
 Use it for your tests in this Rmd thanks to `pkgload::load_all()` to make it available
and `system.file()` to read it in your examples.
-->


# custom recipe steps 

<!--
Create a chunk for the core of the function

- The chunk needs to be named `function` at least
- It contains the code of a documented function
- The chunk can also be named `function-my_median` to make it easily
findable in your Rmd
- Let the `@examples` part empty, and use the next `examples` chunk instead

After inflating the template

-  This function code will be added in a new file in the "R/" directory
-->


<!--
Create a chunk with an example of use for your function

- The chunk needs to be named `examples` at least
- It contains working examples of your function
- The chunk is better be named `examples-my_median` to be handled
correctly when inflated as a vignette

After inflating the template

-  This example will be added in the '@examples' part of our function above in the "R/" directory
- This example will be added in the vignette created from this Rmd template
-->


```{r examples-saturation}
#not run!
library(tidyverse)
library(recipes)
library(tune)
library(mostlytidyMMM)

#create two datasets
mktdata<-rbind(tibble(prod='brand',store='store1',
                      sales=c(100,100,100,100,100),tv=c(10,100,0,0,100),
                      search=c(0,10,20,50,50)) ,
               tibble(prod='brand',store='store2',
                      sales=c(10,10,10,10,10),tv=c(0,0,0,0,0),
                      search=c(0,2,2,0,0) ) ) |> 
  group_by(prod,store)

mktdata2<-tibble(prod='brand',store='all',
                 sales=100,tv=1000,search=1000) |> group_by(prod,store)

#creating a recipe with a saturaiton step in it
rec_obj <-
 recipe(sales ~ ., data = mktdata) |>
 step_saturation(c(tv,search),asymptote=200,saturation_speed=.003 ) |>
 prep(training = mktdata)

#showing what a tunable recipe looks liek:
rec_obj2<-  recipe(sales ~ ., data = mktdata) |>
  step_saturation(c(tv,search),asymptote=tune(),saturation_speed=tune() )

extract_parameter_set_dials(rec_obj2)

 #custom print shows values of saturation hyperparameters:
 print(rec_obj)
 #or shows that they are set to be tuned:
 print(rec_obj2)
 #producing the transformed dataset:
 bake(rec_obj,mktdata)

```

<!--
Create a chunk with a test of use for your function

- The chunk needs to be named `tests` at least
- It contains working tests of your function
- The chunk is better be named `tests-my_median` to be handled
correctly when inflated as a vignette

After inflating the template

-  This test code will be added in the "tests/testthat/" directory
-->


```{r examples-adstock}
library(tidyverse)
library(recipes)
library(tune)
library(mostlytidyMMM)
#create two datasets:
mktdata<-rbind(tibble(prod='brand',store='store1',
                      sales=c(100.,100.,100.,100.,100.),
                      tv=c(10.,100.,0.,0.,100),
                      search=c(0,10,20,50.,50.)) ,
               tibble(prod='brand',store='store2',
                      sales=c(10.,10,10,10,10),tv=c(0.,0,0,0,0),
                      search=c(0.,2,2,0,0) ) ) |> 
  group_by(prod,store)

mktdata2<-tibble(prod='brand',store='all',sales=100,tv=1000,search=1000) |> group_by(prod,store)

#build a recipe with two different adstock steps -- could be done in one step
rec_obj <-  recipe(sales ~ ., data = mktdata) |> step_adstock(tv,retention=.5,groups=c('prod','store')) |>
  step_adstock(search,retention=.5,groups=c('prod','store')) |>
  prep(training = mktdata)

#showing off the custom print function
print(rec_obj)

#see the final transformed output
bake(rec_obj,mktdata)

#note what happens to store = 'all' in mktdata2:
bake(rec_obj,mktdata2)

#check to make sure that per-variable application of the step_adstock and step-saturation do not break the grouping structure even though
#the output tibble from bake is ungrouped (irritatingly)

rec_both_steps<-recipe(sales~.,data=mktdata) |> 
  step_adstock(tv,retention=.1) |> step_saturation(tv,asymptote=1000,saturation_speed=.001) |>
  step_adstock(search,retention=.1)  |> prep()


bake(rec_both_steps,mktdata)

```

# handling roles and steps in bulk

```{r examples-working-with-recipes}
library(tidyverse)
library(mostlytidyMMM)
library(recipes)
library(tune)


#get control spreadsheet
control_file<-system.file('example model control.xlsx',package='mostlytidyMMM')
var_controls<-readxl::read_xlsx(control_file,'variables')
transform_controls<-readxl::read_xlsx(control_file,'role controls')

data_set=rename_columns_per_controls(read.csv(system.file("example2.csv", package = "mostlytidyMMM")),variable_controls=var_controls)


recipe0<-recipe(head(data_set,n=1) )

recipe1<-recipe0 |> bulk_update_role() |> bulk_add_role()
add_steps_media(recipe1)

recipe1

```

# Creating rethinking::ulam inputs

```{r examples-rehtinking-ulam-related-functions}
library(recipes)
library(tune)
library(tidyverse)
library(mostlytidyMMM)

#get the control file:
control_file<-system.file('example model control.xlsx',package='mostlytidyMMM')
#get each relevant table of the control file:
var_controls<-readxl::read_xlsx(control_file,'variables')
transform_controls<-readxl::read_xlsx(control_file,'role controls')
workflow_controls<-readxl::read_xlsx(control_file,"workflow") %>% select(-desc)

#pull data, add fourier transform columns
data1=rename_columns_per_controls(read.csv(system.file("example2.csv", package = "mostlytidyMMM")),variable_controls=var_controls) %>%  mutate(week=as.Date(week,"%m/%d/%Y")) %>% 
  mutate(across(c(product),as.factor)) %>% group_by(product,store) %>% arrange(product,store,week) %>% 
  mutate(day_int=as.numeric(week),
         cos1=cos(2*pi*day_int/356),
         cos2=cos(4*pi*day_int/356),
         cos3 =cos(6*pi*day_int/356),
         cos4 = cos(8*pi*day_int/356),
         cos5 = cos(10*pi*day_int/356),
         sin1=sin(2*pi*day_int/356),
         sin2=sin(4*pi*day_int/356),
         sin3=sin(6*pi*day_int/356),
         sin4=sin(8*pi*day_int/356),
         sin5=sin(10*pi*day_int/356)) %>% select(-day_int) %>% mutate(store=as.factor(store))

#append several more columns
lotsa_vars<-paste0('x',1:60)
new_x<-replicate(60,runif(nrow(data1))) 
names(new_x)<-lotsa_vars
new_x<-as_tibble(new_x)
#bring the data together:
data_for_lotsa_vars<-cbind(data1 ,new_x)

#make recipes
recipea<-recipe(head(data_for_lotsa_vars,n=1) )
recipeb<-recipea %>% bulk_update_role() %>% bulk_add_role()
recipeb<-recipeb %>% add_steps_media() %>%  step_select(-has_role('postprocess'))
recipec <-recipeb %>% step_mutate(week=as.numeric(week)-19247.65) %>% 
  update_role(c(sin1,sin2,sin3,cos1,cos2,cos3),new_role='time') %>%
  add_role(c(sin1,sin2,sin3,cos1,cos2,cos3),new_role='predictor')
recipec<-recipec %>% update_role(starts_with('x'),new_role='predictor')

# build a model formula in the lmer style from the recipe:
(formula_with_lotsa_vars<-create_formula(recipec))

#build a list suitable for input to rethinking::ulam from the formula and recipe:
(create_ulam_list(model_formula=formula_with_lotsa_vars))


```

<!--

# There can be development actions

Create a chunk with 'development' actions

- The chunk needs to be named `development` or `dev`
- It contains functions that are used for package development only
- Note that you may want to store most of these functions in the 0-dev_history.Rmd file

These are only included in the present flat template file, their content will not be part of the package anywhere else.
-->


# Inflate your package

You're one inflate from paper to box.
Build your package from this very Rmd using `fusen::inflate()`

- Verify your `"DESCRIPTION"` file has been updated
- Verify your function is in `"R/"` directory
- Verify your test is in `"tests/testthat/"` directory
- Verify this Rmd appears in `"vignettes/"` directory

