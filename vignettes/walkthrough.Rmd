---
title: "walkthrough"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{walkthrough}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(mostlytidyMMM)
```

<!-- WARNING - This vignette is generated by {fusen} from dev/flat_full.Rmd: do not edit by hand -->

<!-- Run this 'development' chunk -->
<!-- Store every call to library() that you need to explore your functions -->


# Custom recipe steps 

These functions define adstock and saturation functions ($ f(x) = A*(1-e^{-k*x} $) for use in recipes (ie tidymodels pre-model transformation pipelines).


<!--
Create a chunk with an example of use for your function

- The chunk needs to be named `examples` at least
- It contains working examples of your function
- The chunk is better be named `examples-my_median` to be handled
correctly when inflated as a vignette

After inflating the template

-  This example will be added in the '@examples' part of our function above in the "R/" directory
- This example will be added in the vignette created from this Rmd template
-->


```{r examples-saturation}
#not run!
suppressMessages(suppressWarnings(library(tidyverse)))
suppressMessages(suppressWarnings(library(recipes)))
suppressMessages(suppressWarnings(library(tune)))
suppressMessages(suppressWarnings(library(dials)))
suppressMessages(suppressWarnings(library(mostlytidyMMM)))

#create two datasets
mktdata<-rbind(tibble(prod='brand',store='store1',
                      sales=c(100,100,100,100,100),tv=c(10,100,0,0,100),
                      search=c(0,10,20,50,50)) ,
               tibble(prod='brand',store='store2',
                      sales=c(10,10,10,10,10),tv=c(0,0,0,0,0),
                      search=c(0,2,2,0,0) ) ) |> 
  group_by(prod,store)

mktdata2<-tibble(prod='brand',store='all',
                 sales=100,tv=1000,search=1000) |> group_by(prod,store)

#creating a recipe with a saturaiton step in it
rec_obj <-
 recipe(sales ~ ., data = mktdata) |>
 step_saturation(c(tv,search),asymptote=200,saturation_speed=.003 ) |>
 prep(training = mktdata)

#showing what a tunable recipe looks liek:
rec_obj2<-  recipe(sales ~ ., data = mktdata) |>
  step_saturation(c(tv,search),asymptote=tune(),saturation_speed=tune() )

extract_parameter_set_dials(rec_obj2)

 #custom print shows values of saturation hyperparameters:
 print(rec_obj)
 #or shows that they are set to be tuned:
 print(rec_obj2)
 #producing the transformed dataset:
 bake(rec_obj,mktdata)

```

<!--
Create a chunk with a test of use for your function

- The chunk needs to be named `tests` at least
- It contains working tests of your function
- The chunk is better be named `tests-my_median` to be handled
correctly when inflated as a vignette

After inflating the template

-  This test code will be added in the "tests/testthat/" directory
-->


```{r examples-adstock}
suppressMessages(suppressWarnings(library(tidyverse)))
suppressMessages(suppressWarnings(library(recipes)))
suppressMessages(suppressWarnings(library(tune)))
suppressMessages(suppressWarnings(library(dials)))
suppressMessages(suppressWarnings(library(mostlytidyMMM)))
#create two datasets:
mktdata<-rbind(tibble(prod='brand',store='store1',
                      sales=c(100.,100.,100.,100.,100.),
                      tv=c(10.,100.,0.,0.,100),
                      search=c(0,10,20,50.,50.),
                      week=c(1,2,3,4,5)) ,
               tibble(prod='brand',store='store2',
                      sales=c(10.,10,10,10,10),tv=c(0.,0,0,0,0),
                      search=c(0.,2,2,0,0) ,
                      week=c(1,2,3,4,5)) ) |> 
  group_by(prod,store)

mktdata2<-tibble(prod='brand',store='all',sales=100,tv=1000,search=1000,week=6) |> group_by(prod,store)

#build a recipe with two different adstock steps -- could be done in one step
rec_obj <-  recipe(sales ~ ., data = mktdata) |> step_adstock(tv,retention=.5,groups=c('prod','store')) |>
  step_adstock(search,retention=.5,groups=c('prod','store'),time_id='week') |>
  prep(training = mktdata)

#showing off the custom print function
print(rec_obj)

#see the final transformed output
bake(rec_obj,mktdata)

#note what happens to store = 'all' in mktdata2:
bake(rec_obj,mktdata2)

#check to make sure that per-variable application of the step_adstock and step-saturation do not break the grouping structure even though
#the output tibble from bake is ungrouped (irritatingly)

rec_both_steps<-recipe(sales~.,data=mktdata) |> 
  step_adstock(tv,retention=.1) |> step_saturation(tv,asymptote=1000,saturation_speed=.001) |>
  step_adstock(search,retention=.1,time_id='week')  |> prep()


bake(rec_both_steps,mktdata)

#And adstock steps throw an error if time series isn't regular -- last point is two weeks 
mktdata3<-rbind(tibble(prod='brand',store='store1',
                      sales=c(100.,100.,100.,100.,100.),
                      tv=c(10.,100.,0.,0.,100),
                      search=c(0,10,20,50.,50.),
                      week=c(1,2,3,4,6)) ,
               tibble(prod='brand',store='store2',
                      sales=c(10.,10,10,10,10),tv=c(0.,0,0,0,0),
                      search=c(0.,2,2,0,0) ,
                      week=c(1,2,3,4,6)) ) |> 
  group_by(prod,store)

#not run to allow vignette to knit -- uncomment to see error

# rec1<-recipe(mktdata3) |> step_adstock(search,retention=.1,groups=c('prod','store'),
#                                         time_id='week')|>prep()

#bake(rec1,mktdata3)
```

# Handling Roles and Steps in Bulk

It is not uncommon for a Marketing Mix Model to have dozens of variables.  The functions allow roles and media transformations (ie the adstock and saturation steps) to be applied based on the configuration tables.



```{r examples-working-with-recipes}
suppressMessages(suppressWarnings(library(tidyverse)))
suppressMessages(suppressWarnings(library(mostlytidyMMM)))
suppressMessages(suppressWarnings(library(recipes)))
suppressMessages(suppressWarnings(library(dials)))
suppressMessages(suppressWarnings(library(tune)))


#get control spreadsheet
control_file<-system.file('example model control.xlsx',package='mostlytidyMMM')
var_controls<-readxl::read_xlsx(control_file,'variables')
transform_controls<-readxl::read_xlsx(control_file,'role controls')

data_set=rename_columns_per_controls(read.csv(system.file("example2.csv", package = "mostlytidyMMM")),variable_controls=var_controls)


recipe0<-recipe(head(data_set,n=1) )

recipe1<-recipe0 |> bulk_update_role() |> bulk_add_role()
add_steps_media(recipe1)

recipe1

```

# Creating rethinking::ulam inputs

The ulam function generates a stan program and then runs sampling from it.  It is very flexible, giving a user access to most of what stan can do.  create_ulam_list() is a function that translates a lmer()-style formula into the requisite inputs for ulam.


```{r examples-rehtinking-ulam-related-functions}
suppressMessages(suppressWarnings(library(recipes)))
suppressMessages(suppressWarnings(library(tune)))
suppressMessages(suppressWarnings(library(dials)))
suppressMessages(suppressWarnings(library(tidyverse)))
suppressMessages(suppressWarnings(library(mostlytidyMMM)))

#get the control file:
control_file<-system.file('example model control.xlsx',package='mostlytidyMMM')
#get each relevant table of the control file:
var_controls<-readxl::read_xlsx(control_file,'variables')
transform_controls<-readxl::read_xlsx(control_file,'role controls')
workflow_controls<-readxl::read_xlsx(control_file,"workflow") |> select(-desc)

#pull data, add fourier transform columns

data1<-read.csv(system.file('example2.csv',package='mostlytidyMMM'))|>rename_columns_per_controls(variable_controls=var_controls)|>
  rename_columns_per_controls()|> mutate(week=as.Date(week,"%m/%d/%Y"))|>
  add_fourier_vars(vc=var_controls) |>  add_groups_and_sort(vc=var_controls) 

#append several more columns
lotsa_vars<-paste0('x',1:60)
new_x<-replicate(60,runif(nrow(data1))) 
names(new_x)<-lotsa_vars
new_x<-as_tibble(new_x)

#bring the data together:

data_for_lotsa_vars<-cbind(data1 ,new_x)

#make recipes
recipea<-recipe(head(data_for_lotsa_vars,n=1) )
recipeb<-recipea |> bulk_update_role() |> bulk_add_role()
recipeb<-recipeb |> add_steps_media() |>  step_select(-has_role('postprocess'))
recipec <-recipeb |> step_mutate(week=as.numeric(week)-19247.65) |> 
  update_role(c(sin1,sin2,sin3,cos1,cos2,cos3),new_role='time') |>
  add_role(c(sin1,sin2,sin3,cos1,cos2,cos3),new_role='predictor')
recipec<-recipec |> update_role(starts_with('x'),new_role='predictor')

# build a model formula in the lmer style from the recipe:
(formula_with_lotsa_vars<-create_formula(recipec))

#build a list suitable for input to rethinking::ulam from the formula and recipe:
(create_ulam_list(model_formula=formula_with_lotsa_vars))



```

