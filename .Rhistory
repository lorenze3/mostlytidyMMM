asymptote=x$asymptote,
saturation_speed=x$saturation_speed,
hills=col_names
)
}
#'The saturation bake method
#'
#'@param object recipe or step
#'@param mdata the data fed to the recipe or step
#'
#'@return
#'a transformed dataset
#'
#'@export
bake.step_saturation<-function(object,new_data,...){
vars<-names(object$hills)
groupings<-as.character(groups(new_data))
new_data[,vars]<-new_data[,object$hills] |> reframe(across(everything(),function(x){get_train_saturation(x,
object$asymptote,object$saturation_speed)}))
if(length(groupings)>0) {new_data<-as_tibble(new_data) |> group_by(across(all_of(groupings)))}
else{new_data<-as_tibble(new_data)}
return(new_data)
}
#' print method for saturation steps
#'
#' @param x step
#' @return
#' string
#' @export
print.step_saturation <-
function(x, width = max(20, options()$width - 35), ...) {
print_step(
# Names before prep (could be selectors)
untr_obj = x$terms,
# Names after prep:
tr_obj = names(x$hills),
# Has it been prepped?
trained = x$trained,
# An estimate of how many characters to print on a line:
width = width,
title = paste("Saturation (asymptote=",x$asymptote,"saturation_speed=",x$saturation_speed,"Transformation on")
)
invisible(x)
}
#'tunable method for saturation steps -- used by tune package to identify what each hyperparameter is.
#'
#'@param x step or recipe
#'@return
#'tibble that tune functions can evaluate as hyperparameter information
#'@export
tunable.step_saturation <- function (x, ...) {
tibble::tibble(
name = c("asymptote","saturation_speed"),
call_info = list(list( fun = "asymptote"),list(fun='saturation_speed')),
source = c("recipe","recipe"),
component = c("step_saturation","step_saturation"),
component_id = x$id
)
}
#' dial (ie from the tune package) for asymptote
#'
#' @param range defaults to c(100,300), should be a length2 numeric vector that has the minimum and maximum possible asymptotes for a given variable transformation.  In general the asymptote should be higher than the max value in the historical data.
#' @return
#' a quant param dial
#' @export
asymptote<-function(range=c(100,300)){new_quant_param(type='double',range=range,inclusive=c(FALSE,TRUE),
label=c(asymptote='saturation asymptote'),finalize = NULL)}
#' dial (ie from the tune package) for saturation_speed
#'
#' @param range defaults to c(.0001,.009), should be a length 2 numeric vector that has the minimum and maximum possible saturation speed. Small changes in this value have large impact of rate of saturation.
#' @return
#' a quant param dial
#' @export
saturation_speed<-function(range=c(.0001,.009)){new_quant_param(type='double',range=range,inclusive=c(FALSE,FALSE),                                                            label=c(saturation_speed='saturation speed'),finalize = NULL)}
mktdata<-rbind(tibble(prod='brand',store='store1',sales=c(100,100,100,100,100),tv=c(10,100,0,0,100),search=c(0,10,20,50,50)) ,
tibble(prod='brand',store='store2',sales=c(10,10,10,10,10),tv=c(0,0,0,0,0),search=c(0,2,2,0,0) ) ) |> group_by(prod,store)
mktdata2<-tibble(prod='brand',store='all',sales=100,tv=1000,search=1000) |> group_by(prod,store)
rec_obj <-
recipe(sales ~ ., data = mktdata) |>
step_saturation(c(tv,search),asymptote=200,saturation_speed=.003 ) |>
prep(training = mktdata)
rec_obj2<-  recipe(sales ~ ., data = mktdata) |>
step_saturation(c(tv,search),asymptote=tune(),saturation_speed=tune() )
extract_parameter_set_dials(rec_obj2)
print(rec_obj)
recipes::bake(rec_obj,mktdata)
recipes::bake(rec_obj,mktdata2)
mktdata<-rbind(tibble(prod='brand',store='store1',sales=c(100,100,100,100,100),tv=c(10,100,0,0,100),search=c(0,10,20,50,50)) ,
tibble(prod='brand',store='store2',sales=c(10,10,10,10,10),tv=c(0,0,0,0,0),search=c(0,2,2,0,0) ) ) |> group_by(prod,store)
mktdata2<-tibble(prod='brand',store='all',sales=100,tv=1000,search=1000) |> group_by(prod,store)
rec_obj <-
recipe(sales ~ ., data = mktdata) |>
step_saturation(c(tv,search),asymptote=200,saturation_speed=.003 ) |>
prep(training = mktdata)
rec_obj2<-  recipe(sales ~ ., data = mktdata) |>
step_saturation(c(tv,search),asymptote=tune(),saturation_speed=tune() )
extract_parameter_set_dials(rec_obj2)
print(rec_obj)
bake(rec_obj,mktdata)
bake(rec_obj,mktdata2)
test_that("saturation steps peform as expected in a recipe", {
librarian::shelf(tune,recipes,tidyverse)
mktdata<-rbind(tibble(prod='brand',store='store1',sales=c(100,100,100,100,100),tv=c(10,100,0,0,100),search=c(0,10,20,50,50)) ,
tibble(prod='brand',store='store2',sales=c(10,10,10,10,10),tv=c(0,0,0,0,0),search=c(0,2,2,0,0) ) ) |> group_by(prod,store)
mktdata2<-tibble(prod='brand',store='all',sales=100,tv=1000,search=1000) |> group_by(prod,store)
rec_obj <-
recipe(sales ~ ., data = mktdata) |>
step_saturation(c(tv,search),asymptote=200,saturation_speed=.003 ) |>
prep(training = mktdata)
rec_obj2<-  recipe(sales ~ ., data = mktdata) |>
step_saturation(c(tv,search),asymptote=tune(),saturation_speed=tune() )
true_mktdata_baked<-readRDS(system.file("baked_mktdata_sat_only.RDS", package = "mostlytidyMMM"))
true_mktdata2_baked<-readRDS(system.file("baked_mktdata2_sat_only.RDS", package = "mostlytidyMMM"))
true_tunable<-readRDS(system.file("check_sat_tunable.RDS", package = "mostlytidyMMM"))
expect_true(extract_parameter_set_dials(rec_obj2)==true_tunable)
expect_true( bake(rec_obj,mktdata)==true_mktdata_baked)
expect_true( bake(rec_obj,mktdata2)==true_mktdata2_baked)
expect_error(my_median("text"))
})
bake(rec_obj,mktdata)
true_mktdata_baked
true_mktdata_baked<-readRDS(system.file("baked_mktdata_sat_only.RDS", package = "mostlytidyMMM"))
true_mktdata_baked
bake(rec_obj,mktdata)==true_mktdata_baked
test_that("saturation steps peform as expected in a recipe", {
librarian::shelf(tune,recipes,tidyverse)
mktdata<-rbind(tibble(prod='brand',store='store1',sales=c(100,100,100,100,100),tv=c(10,100,0,0,100),search=c(0,10,20,50,50)) ,
tibble(prod='brand',store='store2',sales=c(10,10,10,10,10),tv=c(0,0,0,0,0),search=c(0,2,2,0,0) ) ) |> group_by(prod,store)
mktdata2<-tibble(prod='brand',store='all',sales=100,tv=1000,search=1000) |> group_by(prod,store)
rec_obj <-
recipe(sales ~ ., data = mktdata) |>
step_saturation(c(tv,search),asymptote=200,saturation_speed=.003 ) |>
prep(training = mktdata)
rec_obj2<-  recipe(sales ~ ., data = mktdata) |>
step_saturation(c(tv,search),asymptote=tune(),saturation_speed=tune() )
true_mktdata_baked<-readRDS(system.file("baked_mktdata_sat_only.RDS", package = "mostlytidyMMM"))
true_mktdata2_baked<-readRDS(system.file("baked_mktdata2_sat_only.RDS", package = "mostlytidyMMM"))
true_tunable<-readRDS(system.file("check_sat_tunable.RDS", package = "mostlytidyMMM"))
expect_true(identical(extract_parameter_set_dials(rec_obj2),true_tunable))
expect_true( identical(bake(rec_obj,mktdata),true_mktdata_baked))
expect_true( identical( bake(rec_obj,mktdata2),true_mktdata2_baked))
})
true_tunable<-readRDS(system.file("check_sat_tunable.RDS", package = "mostlytidyMMM"))
true_tunable
extract_parameter_set_dials(rec_obj2)
extract_parameter_set_dials(rec_obj2)
saveRDS(extract_parameter_set_dials(rec_obj2),'true_tunable_saturation.RDS')
true_tunable<-readRDS(system.file("true_tunable_saturation.RDS", package = "mostlytidyMMM"))
test_that("saturation steps peform as expected in a recipe", {
librarian::shelf(tune,recipes,tidyverse)
mktdata<-rbind(tibble(prod='brand',store='store1',sales=c(100,100,100,100,100),tv=c(10,100,0,0,100),search=c(0,10,20,50,50)) ,
tibble(prod='brand',store='store2',sales=c(10,10,10,10,10),tv=c(0,0,0,0,0),search=c(0,2,2,0,0) ) ) |> group_by(prod,store)
mktdata2<-tibble(prod='brand',store='all',sales=100,tv=1000,search=1000) |> group_by(prod,store)
rec_obj <-
recipe(sales ~ ., data = mktdata) |>
step_saturation(c(tv,search),asymptote=200,saturation_speed=.003 ) |>
prep(training = mktdata)
rec_obj2<-  recipe(sales ~ ., data = mktdata) |>
step_saturation(c(tv,search),asymptote=tune(),saturation_speed=tune() )
true_mktdata_baked<-readRDS(system.file("baked_mktdata_sat_only.RDS", package = "mostlytidyMMM"))
true_mktdata2_baked<-readRDS(system.file("baked_mktdata2_sat_only.RDS", package = "mostlytidyMMM"))
true_tunable<-readRDS(system.file("true_tunable_saturation.RDS", package = "mostlytidyMMM"))
expect_true(identical(extract_parameter_set_dials(rec_obj2),true_tunable))
expect_true( identical(bake(rec_obj,mktdata),true_mktdata_baked))
expect_true( identical( bake(rec_obj,mktdata2),true_mktdata2_baked))
})
true_tunable
View(true_tunable)
View(extract_parameter_set_dials(rec_obj2))
extract_parameter_set_dials(rec_obj2)==true_tunable
test_that("saturation steps peform as expected in a recipe", {
librarian::shelf(tune,recipes,tidyverse)
mktdata<-rbind(tibble(prod='brand',store='store1',sales=c(100,100,100,100,100),tv=c(10,100,0,0,100),search=c(0,10,20,50,50)) ,
tibble(prod='brand',store='store2',sales=c(10,10,10,10,10),tv=c(0,0,0,0,0),search=c(0,2,2,0,0) ) ) |> group_by(prod,store)
mktdata2<-tibble(prod='brand',store='all',sales=100,tv=1000,search=1000) |> group_by(prod,store)
rec_obj <-
recipe(sales ~ ., data = mktdata) |>
step_saturation(c(tv,search),asymptote=200,saturation_speed=.003 ) |>
prep(training = mktdata)
rec_obj2<-  recipe(sales ~ ., data = mktdata) |>
step_saturation(c(tv,search),asymptote=tune(),saturation_speed=tune() )
true_mktdata_baked<-readRDS(system.file("baked_mktdata_sat_only.RDS", package = "mostlytidyMMM"))
true_mktdata2_baked<-readRDS(system.file("baked_mktdata2_sat_only.RDS", package = "mostlytidyMMM"))
true_tunable<-readRDS(system.file("true_tunable_saturation.RDS", package = "mostlytidyMMM"))
# expect_true(identical(extract_parameter_set_dials(rec_obj2),true_tunable))
expect_true( identical(bake(rec_obj,mktdata),true_mktdata_baked))
expect_true( identical( bake(rec_obj,mktdata2),true_mktdata2_baked))
})
library(mostlytidyMMM)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(mostlytidyMMM)
mktdata<-rbind(tibble(prod='brand',store='store1',sales=c(100,100,100,100,100),tv=c(10,100,0,0,100),search=c(0,10,20,50,50)) ,
tibble(prod='brand',store='store2',sales=c(10,10,10,10,10),tv=c(0,0,0,0,0),search=c(0,2,2,0,0) ) ) |> group_by(prod,store)
mktdata2<-tibble(prod='brand',store='all',sales=100,tv=1000,search=1000) |> group_by(prod,store)
rec_obj <-
recipe(sales ~ ., data = mktdata) |>
step_saturation(c(tv,search),asymptote=200,saturation_speed=.003 ) |>
prep(training = mktdata)
rec_obj2<-  recipe(sales ~ ., data = mktdata) |>
step_saturation(c(tv,search),asymptote=tune(),saturation_speed=tune() )
extract_parameter_set_dials(rec_obj2)
print(rec_obj)
recipes::bake(rec_obj,mktdata)
recipes::bake(rec_obj,mktdata2)
fusen::inflate()
rm(list = c("asymptote", "get_train_saturation", "saturation_speed", "step_saturation"))
fusen::inflate()
fusen::inflate()
fusen::inflate()
rm(list = c("step_saturation_new"))
.Last.error
?fusen::fill_description
# Describe your package
fusen::fill_description(
pkg = here::here(),
fields = list(
Title = "A Complete MMM workflow in R",
Description = "a hybrid MMM approach built on tidymodels and McElreath's rethinking packages",
`Authors@R` = c(
person("Lorenzen", "Ted", email = "lorenze3@gmail.com", role = c("aut", "cre")
)
),
Depends = c(tidymodels,tidyverse,rethinking)
),
overwrite=T
)
# Define License with use_*_license()
usethis::use_mit_license("Ted Lorenzen")
# Describe your package
fusen::fill_description(
pkg = here::here(),
fields = list(
Title = "A Complete MMM workflow in R",
Description = "a hybrid MMM approach built on tidymodels and McElreath's rethinking packages",
`Authors@R` = c(
person("Lorenzen", "Ted", email = "lorenze3@gmail.com", role = c("aut", "cre")
)
),
Depends = c('tidymodels','tidyverse','rethinking')
),
overwrite=T
)
# Define License with use_*_license()
usethis::use_mit_license("Ted Lorenzen")
fusen::inflate()
# Describe your package
fusen::fill_description(
pkg = here::here(),
fields = list(
Title = "A Complete MMM workflow in R",
Description = "a hybrid MMM approach built on tidymodels and McElreath's rethinking packages",
`Authors@R` = c(
person("Lorenzen", "Ted", email = "lorenze3@gmail.com", role = c("aut", "cre")
)
),
Depends = 'tidymodels'
),
overwrite=T
)
# Define License with use_*_license()
usethis::use_mit_license("Ted Lorenzen")
# Describe your package
fusen::fill_description(
pkg = here::here(),
fields = list(
Title = "A Complete MMM workflow in R",
Description = "a hybrid MMM approach built on tidymodels and McElreath's rethinking packages.",
`Authors@R` = c(
person("Lorenzen", "Ted", email = "lorenze3@gmail.com", role = c("aut", "cre")
)
),
Depends = 'tidymodels'
),
overwrite=T
)
# Define License with use_*_license()
usethis::use_mit_license("Ted Lorenzen")
fusen::inflate()
fff<-recipes::bake
fff
fff()
fff(rec_obj)
fusen::inflate()
# Describe your package
fusen::fill_description(
pkg = here::here(),
fields = list(
Title = "A Complete MMM workflow in R",
Description = "a hybrid MMM approach built on tidymodels and McElreath's rethinking packages.",
`Authors@R` = c(
person("Lorenzen", "Ted", email = "lorenze3@gmail.com", role = c("aut", "cre")
)
)
),
overwrite=T
)
# Define License with use_*_license()
usethis::use_mit_license("Ted Lorenzen")
fusen::inflate()
# Describe your package
fusen::fill_description(
pkg = here::here(),
fields = list(
Title = "A Complete MMM workflow in R",
Description = "a hybrid MMM approach built on tidymodels and McElreath's rethinking packages.",
`Authors@R` = c(
person("Lorenzen", "Ted", email = "lorenze3@gmail.com", role = c("aut", "cre")
)
)
),
overwrite=T
)
# Define License with use_*_license()
usethis::use_mit_license("Ted Lorenzen")
fusen::inflate()
fusen::inflate()
fusen::inflate()
fusen::inflate()
fusen::inflate()
#' working around some fusen issue; re-exporting bake to this namespace
#' @export
bake<-recipes::bake
#' working around some fusen issue; re-exporting bake to this namespace
#' @export
prep<-recipes::prep
#' working around some fusen issue; re-exporting bake to this namespace
#' @export
tunable<-tune::tunable
#' function to add saturation trasnformations to a recipe
#'
#' @param recipe a recipes::recipe
#' @param ... variables in recipe to be effected by the step
#' @param role defaults to NA, set to a string to change the role of the transformed variables
#' @param asymptote defaults to 100, the asymptotic value of the saturation transformed variable
#' @param saturation_speed defaults to .05, controls how quickly the asymptote is approached
#' @param id default value will work most often, but can be set manually for use with tuning fuctions
#'
#' @return
#' a recipe with the new saturation step appended
#' @export
#'
#' @examples
step_saturation <- function(
recipe,
...,
role = NA,
trained = FALSE,
options = list( names = TRUE),
skip = FALSE,
asymptote=100,
saturation_speed=.05,
hills=NULL,
id = rand_id("saturation")
) {
add_step(
recipe,
step_saturation_new(
terms = enquos(...),
trained = trained,
role = role,
options = options,
skip = skip,
id = id,
asymptote=asymptote,
saturation_speed=saturation_speed,
hills=hills
)
)
}
#' internal function used in create recipe steps
#'
#'
#' @return
#' a recipe sep of type saturation
#' @export
step_saturation_new <-
function(terms, role, trained, asymptote,saturation_speed,hills, options, skip, id) {
step(
subclass = "saturation",
terms = terms,
role = role,
trained = trained,
asymptote=asymptote,
saturation_speed=saturation_speed,
hills=hills,
options = options,
skip = skip,
id = id
)
}
#' a monotonic saturation function with monotonic first deriviate used in recipes for preprocssing MMM data
#'
#' @param x vector of numeric value to saturate
#' @param asymptote the asymptote of the transformed values; should probably exceed the max value in the modeled data
#' @param saturation_speed higher values approach the asymptote faster
#'
#'
#' @return
#' a numeric vector of transformed values
#' @export
#worker bee function
get_train_saturation<-function(x,asymptote,saturation_speed){
stopifnot(length(asymptote) == 1)
stopifnot(length(saturation_speed) == 1)
x_scurve<-asymptote*(1-exp(-saturation_speed*x))
return(x_scurve)
}
#' The saturation step prep method
#'
#' @param x an object (step or recipe)
#' @param training  tibble used to provide data for training
#'
#' @return
#' a prepped recipe or step
#' @export
prep.step_saturation <- function(x, training, info = NULL, ...) {
#this will select the appropriate columns from the training set
col_names <- recipes_eval_select(x$terms, training, info)
## We'll use the names later so make sure they are available
if (x$options$names == FALSE) {
rlang::abort("`names` should be set to TRUE")
}
#transforms computed here
step_saturation_new(terms=x$terms,
trained=TRUE,
role=x$role,
options=x$options,
skip=x$skip,
id=x$id,
asymptote=x$asymptote,
saturation_speed=x$saturation_speed,
hills=col_names
)
}
#'The saturation bake method
#'
#'@param object recipe or step
#'@param mdata the data fed to the recipe or step
#'
#'@return
#'a transformed dataset
#'
#'@export
bake.step_saturation<-function(object,new_data,...){
vars<-names(object$hills)
groupings<-as.character(groups(new_data))
new_data[,vars]<-new_data[,object$hills] |> reframe(across(everything(),function(x){get_train_saturation(x,
object$asymptote,object$saturation_speed)}))
if(length(groupings)>0) {new_data<-as_tibble(new_data) |> group_by(across(all_of(groupings)))}
else{new_data<-as_tibble(new_data)}
return(new_data)
}
#' print method for saturation steps
#'
#' @param x step
#' @return
#' string
#' @export
print.step_saturation <-
function(x, width = max(20, options()$width - 35), ...) {
print_step(
# Names before prep (could be selectors)
untr_obj = x$terms,
# Names after prep:
tr_obj = names(x$hills),
# Has it been prepped?
trained = x$trained,
# An estimate of how many characters to print on a line:
width = width,
title = paste("Saturation (asymptote=",x$asymptote,"saturation_speed=",x$saturation_speed,"Transformation on")
)
invisible(x)
}
#'tunable method for saturation steps -- used by tune package to identify what each hyperparameter is.
#'
#'@param x step or recipe
#'@return
#'tibble that tune functions can evaluate as hyperparameter information
#'@export
tunable.step_saturation <- function (x, ...) {
tibble::tibble(
name = c("asymptote","saturation_speed"),
call_info = list(list( fun = "asymptote"),list(fun='saturation_speed')),
source = c("recipe","recipe"),
component = c("step_saturation","step_saturation"),
component_id = x$id
)
}
#' dial (ie from the tune package) for asymptote
#'
#' @param range defaults to c(100,300), should be a length2 numeric vector that has the minimum and maximum possible asymptotes for a given variable transformation.  In general the asymptote should be higher than the max value in the historical data.
#' @return
#' a quant param dial
#' @export
asymptote<-function(range=c(100,300)){new_quant_param(type='double',range=range,inclusive=c(FALSE,TRUE),
label=c(asymptote='saturation asymptote'),finalize = NULL)}
#' dial (ie from the tune package) for saturation_speed
#'
#' @param range defaults to c(.0001,.009), should be a length 2 numeric vector that has the minimum and maximum possible saturation speed. Small changes in this value have large impact of rate of saturation.
#' @return
#' a quant param dial
#' @export
saturation_speed<-function(range=c(.0001,.009)){new_quant_param(type='double',range=range,inclusive=c(FALSE,FALSE),                                                            label=c(saturation_speed='saturation speed'),finalize = NULL)}
showMethods('bake')
showmethods('bake')
methods('bake')
methods('prep')
rm(list=ls())
fusen::inflate()
