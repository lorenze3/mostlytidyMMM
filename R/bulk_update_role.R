# WARNING - Generated by {fusen} from dev/flat_full.Rmd: do not edit by hand

#functions to loop over controls tibbles and create recipe steps

#' loops over the variable control table to assign roles within a recipe.  These
#' roles control transformations applied and construction of model formulas
#' 
#' @param this_recipe a recipe object
#' @param vars_to_append_roles Defaults to var_controls$varname; a vector of variable names that will have updated roles
#' @param roles_to_be_appended Defaults to var_controls$role; a vector of roles that match the vars_to_append_roles vector
#' 
#' @return a recipe

#' @export
#' 
#' @example
#'
#' library(tidyverse)
#' library(mostlytidyMMM)
#' library(recipes)
#' library(dials)
#' library(tune)
#'
#'
#' #get control spreadsheet
#' control_file<-system.file('example model control.xlsx',package='mostlytidyMMM')
#' var_controls<-readxl::read_xlsx(control_file,'variables')
#' transform_controls<-readxl::read_xlsx(control_file,'role controls')
#'
#' data_set=rename_columns_per_controls(read.csv(system.file("example2.csv", package = "mostlytidyMMM")),variable_controls=var_controls)
#'
#'
#' recipe0<-recipe(head(data_set,n=1) )
#'
#' recipe1<-recipe0 |> bulk_update_role() |> bulk_add_role()
#' add_steps_media(recipe1)
#'
#' recipe1
#'
bulk_update_role<-function(this_recipe,vars_to_append_roles=var_controls$varname,roles_to_be_appended=var_controls$role){
  unique_roles<-unique(roles_to_be_appended)
  for (i in 1:length(unique_roles)){
    this_role<-unique_roles[i]
    this_recipe<-this_recipe |> update_role(vars_to_append_roles[roles_to_be_appended==this_role],
                                             new_role=this_role)
  }
  return(this_recipe)
}

#' loops over the variable control table to assign _second_ rolls within a recipe. These roles control transformations applied and construction of model formulas
#' 
#' @param this_recipe a recipe object
#' @param vars_to_append_roles Defaults to var_controls$varname[!is.na(var_controls$role2)]; a vector of variable names that will have updated roles
#' @param roles_to_be_appended Defaults to var_controls$role2[!is.na(var_controls$role2)]; a vector of roles that match the vars_to_append_roles vector
#' 
#' @return a recipe
#' 
#' @export
#' 
#' @example
#' 
bulk_add_role<-function(this_recipe,vars_to_append_roles=var_controls$varname[!is.na(var_controls$role2)],roles_to_be_appended=var_controls$role2[!is.na(var_controls$role2)]){
  unique_roles<-unique(roles_to_be_appended)
  for (i in 1:length(unique_roles)){
    this_role<-unique_roles[i]
    this_recipe<-this_recipe |> add_role(vars_to_append_roles[roles_to_be_appended==this_role],
                                          new_role=this_role)
  }
  return(this_recipe)
}


#' loops over the variable control table to add media transformations based on either variable specific transformations or tunable ranges
#' @param this_recipe a recipe object
#' @param var_specfic_controls Defaults to var_controls; a tibble containing variable name, role, role2, asymptote, saturation_speed, sign , and retention values (or blanks)
#' @param media_controls Defaults to transform_controls; a tibble containing groups of variables (ie role2 values) that assignes ranges to asymptote, saturation_speed, and retention IF there are no values for the individual variables
#' 
#' @return a recipe
#' 
#' @export
#' 
#' @example
#' 
add_steps_media<-function(this_recipe,var_specific_controls=var_controls,media_controls=transform_controls){
  #two cases -- specific variable settings in var_specific_controls or not.
  
  #find var specific controls here.  
  
  var_specific_controls <-var_specific_controls |> select(varname,retention,asymptote,saturation_speed) |> 
    mutate(across(c(retention,asymptote,saturation_speed),as.numeric) )|> 
    filter(!is.na(retention) | !is.na(asymptote) |!is.na(saturation_speed)) 
  
  n_specific_controls<-nrow(var_specific_controls)
  
  vars_to_skip<-vector('character') #this will hold vars with specific settings so they are skipped when doing group -based transforms
  
  these_groups<-as.character(groups(this_recipe$template))
  
  if(n_specific_controls>0){
    for(specific in 1:n_specific_controls){
      this_row<-var_specific_controls[specific,c('varname','asymptote','saturation_speed','retention')]
      this_var<-var_specific_controls$varname[specific]
      asymptote_id=paste0(this_var,'_asymptote')
      saturation_speed_id=paste0(this_var,'_saturation_speed')
      retention_id=paste0(this_var,'_retention')
      if(is.na(var_specific_controls$asymptote[specific])){this_asymptote<-tune(asymptote_id)}else{this_asymptote<-var_specific_controls$asymptote[specific]}
      if(is.na(var_specific_controls$saturation_speed[specific])){this_saturation_speed<-tune(saturation_speed_id)}else{this_saturation_speed<-var_specific_controls$saturation_speed[specific]}
      if(is.na(var_specific_controls$retention[specific])){this_retention<-tune(retention_id)}else{this_retention<-var_specific_controls$retention[specific]}
      
      this_recipe<-this_recipe |> step_adstock(!!this_var,retention=this_retention,groups = these_groups) |>
        step_saturation(!!this_var,asymptote=this_asymptote,saturation_speed=this_saturation_speed)
    }
    #don't need to add steps for any of those variables, so make list to keep out in the settings by role
    vars_to_skip<-var_specific_controls$varname
  }
  
  if(nrow(media_controls)>0){
    for(group_no in 1:nrow(media_controls)){
      this_role<-media_controls$role[group_no]
      asymptote_id<-paste0(this_role,'_asymptote')
      saturation_speed_id<-paste0(this_role,'_saturation_speed')
      retention_id<-paste0(this_role,'_retention')
      
      if(media_controls$retention_high[group_no]==media_controls$retention_low[group_no]){
        this_retention<-media_controls$retention_high[group_no]}else{this_retention<-tune(retention_id)}
      if(media_controls$asymptote_high[group_no]==media_controls$asymptote_low[group_no]){
        this_asymptote<-media_controls$asymptote_high[group_no]}else{this_asymptote<-tune(asymptote_id)}
      if(media_controls$saturation_speed_high[group_no]==media_controls$saturation_speed_low[group_no]){
        this_saturation_speed<-media_controls$saturation_speed_high[group_no]}else{this_saturation_speed<-tune(saturation_speed_id)}
      
      if(length(vars_to_skip)>0){  
       vars_with_role<-summary(this_recipe) |> group_by(variable) |> 
          summarise(roles=paste(role,collapse=',')) |> 
         filter(grepl("predictor",roles,fixed=T),grepl(this_role,roles,fixed=T),
                !(variable %in% !!vars_to_skip) )|> select(variable) |> distinct() |> unlist()
        if(length(vars_with_role)>0){
          this_recipe<-this_recipe |> step_adstock(all_of(vars_with_role),
                                                    retention = this_retention,groups = these_groups) |> 
            step_saturation(all_of(vars_with_role),
                      asymptote=this_asymptote,
                      saturation_speed=this_saturation_speed)
          }
       }
      else{
        this_recipe<-this_recipe |> step_adstock(has_role(!!this_role),
                                                  retention = this_retention,groups=these_groups) |> 
          step_saturation(has_role(!!this_role),
                          asymptote=this_asymptote,
                          saturation_speed=this_saturation_speed)
      }
    }
  }
  return(this_recipe)
}

#' renames columns in data per the controls file
#' @param working_df is the dataset that needs to be renamed in a tibble or data.frame
#' @param variable_controls Defaults to var_controls; a tibble containing start_name and varname, with varname being the desired final name of each columns
#' @return
#' a tibble with (potentially) renamed columns
#' 
#' @export
#' 
#' @example
rename_columns_per_controls<-function(working_df,variable_controls=var_controls){
  new_names<-variable_controls$varname[match(names(working_df),variable_controls$start_name)]
  #catch for names not in the controls table
  na_idx<-which(is.na(new_names))
  new_names[na_idx]<-names(working_df)[na_idx]
  #rename
  names(working_df)<-new_names
  return(working_df)
}

#' computes variables suitable for seasonality predictors
#' @param data_to_use defaults to data1; suitable for MMM and with variables matching the vc table
#' @param vc deafults to var_controls; tibble with varname and role indicating which
#' variable is the time_id column
#' @export
#' @example
#' 
add_fourier_vars<-function(data_to_use=data1,vc=var_controls){
  time_id_var <-vc|> filter(role=='time_id') |> select(varname) |> unlist()
  
  time_id_vec<-data_to_use |> select(all_of(time_id_var)) |> unlist()
  if(!is.numeric(time_id_vec)){stop("non numeric vector used as time_id var.  
                                  For variable set as time_id var (ie where role=time_id), please reset it to be a date or number representing a date ")}
  
  data_to_use$day_int=time_id_vec
  return(data_to_use |> mutate(cos1=cos(2*pi*day_int/356),
                                cos2=cos(4*pi*day_int/356),
                                cos3 =cos(6*pi*day_int/356),
                                cos4 = cos(8*pi*day_int/356),
                                cos5 = cos(10*pi*day_int/356),
                                sin1=sin(2*pi*day_int/356),
                                sin2=sin(4*pi*day_int/356),
                                sin3=sin(6*pi*day_int/356),
                                sin4=sin(8*pi*day_int/356),
                                sin5=sin(10*pi*day_int/356)) |> select(-day_int))
}



#' sorts and groups data per the variable controls table
#' 
#' @param data_to_use defaults to data1;  a tibble or tidytable suitable for MMM and matching the 
#' variables listed in vc (the variable congtrol table)
#' @param vc defaults to var_controls; a tibble with varname, role, role2, describing
#' the roles variables will play in the MMM
#' @export
#' @return
#' a tibble 
#' @importFrom dplyr filter
#' @importFrom dplyr select
#' @importFrom dplyr mutate
#' @importFrom dplyr across
#' @importFrom dplyr all_of
#' @importFrom dplyr arrange
add_groups_and_sort<-function(data_to_use=data1,vc=var_controls){
  #extract groups from vc
  groupings<-vc |> filter(role2=='group') |> select(varname) |> unlist()
  names(groupings)<-NULL
  time_id_var <-vc|> filter(role=='time_id') |> select(varname) |> unlist()
  if(length(groupings)>0){
    
    data_to_use<-data_to_use|> 
      mutate(across(all_of(!!groupings),as.factor))
    
    return(data_to_use |>  group_by(across(all_of(groupings))) |> 
             arrange(across(all_of( c(!!groupings,!!time_id_var)))) )
  }
  else{
    return(data_to_use |> arrange(across(all_of(c(!!time_id_var))) )
           ) }
}

#'check to see if a recipe needs to be finalized before baking
#'
#' @param recipe_to_check a recipe
#' @return booelan true or false
#' @example
#' @details
#'This function wraps prep(recipe_to_check) in tryCatch to produce a TRUE/FALSE on
#'if the recipe still has tune() in some of its parameters.
#'This will be inefficient in the situation where the data in the recipe is large or the
#'prep steps are lengthy
#' @export
#' @importFrom recipes prep
#'
check_if_needs_tune<-function(recipe_to_check){
  tryCatch({recipes::prep(recipe_to_check)
    FALSE},error=function(e) {
      if(grepl("Argument(s) with `tune()`:",e$message,fixed=T))
      return(TRUE) })
}


#' reads the variable controls configuration and dataset to create a recipe, 
#' which may include tuning dials
#' 
#' @param data_to_use defaults to data1, should be a tibble or tidytable that 
#' has variable names and structure useable as template for the MMM data
#' @param vc defaults to var_controls, should be a tibble describing individual
#' variable roles (ie role and role 2 and varname are included inthe tibble).
#' @param mc defaults to transform_controls; a tibble with hyperparameter ranges
#' by role (ie media type)
#' @param wc defaults to workflow_controls; a tibble with R_name and Value columns
#' where R_name holds control names expected by several of this package's functions
#' and Value is the value of those controls
#' @export
#' 
#' @example
#' 
#' @return a recipe with roles, adstock and saturation steps defined by controls table
#' 
#' @importFrom tune finalize_recipe
#' @importFrom recipes recipe
create_recipe<-function(data_to_use=data1,vc=var_controls,mc=transform_controls,
                        wc=workflow_controls){
  #start recipe by assigning roles
  #  small data is good, going to need to loop over recipe repeatedly, lots of internal copying
  
  groupings<-as.character(groups(data_to_use))
  
  recipe0<-recipe(head(data_to_use,n=1) ) 
  
  recipe1<-recipe0 |> bulk_update_role() |> bulk_add_role() 
  
  recipe2<-recipe1 |> add_steps_media(var_specific_controls=vc,media_controls=mc) |>  step_select(-has_role('postprocess'))
  
  recipe3 <-recipe2  |># step_center(week) |>
    update_role(c(sin1,sin2,sin3,sin4,sin5,cos1,cos2,cos3,cos4,cos5),new_role='time') |> 
    add_role(c(sin1,sin2,sin3,sin4,sin5,cos1,cos2,cos3,cos4,cos5),new_role='predictor') |> 
    step_novel(all_of(!!groupings)) |> 
    step_mutate_at(all_of(!!groupings),fn=list(id=as.integer))
  
  if(get_control('tune_this_time',wc)=='FALSE'){
    if(check_if_needs_tune(recipe3)){
    if(get_control('saved_hypers_filename') =='' | 
       is.na(get_control('saved_hypers_filename') ) ){
      stop("workflow controls calling for skipping tuning but the saved_hypers_filename control is empty!
            Fill that control in with the location of saved hyperparameters")
     }
     recipe3<-recipe3|>tune::finalize_recipe(readRDS(get_control('saved_hypers_filename',wc)))
    }
  }
  return(recipe3)
}

